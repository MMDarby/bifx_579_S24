---
title: "README for Pipeline Development"
author: "Alyssa Klein"
date: "2/14/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Scripts Created for Pipeline Development

### The following are the name of the .R files for the scripts created over the process of developing the pipeline:

```
1) canonical_seq_download_nov22_2019.R
2) protein_domain_comparison.R
3) nmd_determination.R
4) Differential Expresssion Analysis Scripts for Individual recount Studies:
  4a) SRP037725_differential_expression_putative_regions.R
  4b) ERP001304_differential_expression_putative_regions.R
  4c) SRP035524_differential_expression_putative_regions.R
  4d) SRP043684_differential_expression_putative_regions.R
```

### canonical_seq_download_nov22_2019.R
```
The purpose of this script is to take the gene ids and convert them to the appropriate UniProt IDs.  There are two steps in this script. The first is to select for the UniProt IDs and entry names for each of the gene ids. This step contains an intermediary step where alternative gene names are identified for genes that did not have a UniProt ID. The IDs identified are then used to download the FASTA canonical protein sequences. 

The UniProt IDs are the information necessary for the FASTA sequence download.  You will see that I have also identified the UniProt Entry Name in case it was needed later on in research.

You will see that the input file is a simple text file, "gene_ids_for_conversion_script.txt".  This file contains only the gene ids that need to be matched with a protein id in UniProt.

The first step is to convert as many of the gene ids to UniProt ids as possible. This generates two files- the first being the gene names to ids for repeated gene ids, and the other the UniProt ids for only unique gene ids (this way each is observed only one time rather than multiple). These files include:
1) "gene_names_to_ids.csv"
2) "unique_gene_names_to_ids.csv"

The next step it to convert as many of the gene ids to the UniProt entry names as possible. This generates two files- the first being the gene names to ids for repeated gene ids, and the other the UniProt entry names for only unique gene ids (this way each is observed only one time rather than multiple). It is not necessary to download the entry names, but I have done so in case this information is needed at a later time. These files include:
1) "gene_names_to_entrynames.csv"
2)  "unique_gene_names_to_entrynames.csv"

Following determination of as many UniProt ids and entry names intially, I went ahead and determined which gene ids did not identify with a UniProt id.  The two files below were generated to visualize these gene ids:
1) "gene_ids_no_uniprot_ids.csv"
2) "unique_gene_ids_no_uniprot_ids.csv"

With a list of gene ids without a match to a UnipProt id, I used GeneCards to determine if the gene was not protein coding, or if it fell under an alternative gene name. After determing which gene were protein coding and simply had an alternative gene name, I created the following file with these gene ids:
1) "updated_gene_ids_for_original_no_matches.txt"

Then I repeated the process that had been carried out initially, determing UniProt ids and UniProt entry names for those gene ids that originally did not have an id match. The files generated are as follows:

For UniProt ids:
1) "gene_names_to_ids_orig_no_matches.csv"
2) "unique_gene_names_to_ids_orig_no_matches.csv"

For UniProt entry names:
1) "gene_names_to_entrynames_orig_no_matches.csv"
2) "unique_gene_names_to_entrynames_orig_no_matches.csv"

The last step of the script allows for the download of the desired sequences from UniProt. The input file is a list of all of the UniProt ids- this is a combination of the initial ids and the ids identified for the originally unmatched ids.  This file is entitled: "uniprot_ids_for_canonical_download.txt". The output file generated with all of the sequences is entitled: "canonical_seqs.fasta".

### Note: The isoform sequences were generated through the download of the nucleotide sequences of the putative regions and the two flanking exons, determining the reading frame of the first exon, and translating the nucleotide sequence using Expasy Translate.  This sequence was then inserted into the canonical sequence where appropriate. 
```

### protein_domain_comparison.R
```
There are two main things occurring in this script, with the main goal being to identify the loss/gain of functional domains when going from the canonical protein to the novel isoform. The first step of the script takes in the domain information files that have been generated for both the canonical domains and the isoform domains through the use of Amazon Web Services (AWS). These files have been simplified from what was generated by AWS (which outputs a .html).  The next step is the generation of an individual file for each unique Seq_ID (i.e. UniProt ID) that contains the domain assignments for each, the evalues, and match regions.  The final step of the script is the output of loss/gain of domains.  This is outputted as a text file with the name "domain_information_output.txt".

Before using the script, the user should take the information generated by AWS and simmplify it to what is needed for running the script. This information includes the following column names: "Protei_name", "Seq_ID", "Match_region", "SCOP_superfamily", and "E_value". This information is found in two different files- one for the canonical sequences and the other for the novel protein isoform sequences. Note: "NA" has been inserted into any blank cell so it is easier understood when running the script. The following are the file names that contain the domain assignment information:

1) "superfamily_domains_canonical_for_script.csv"
2) "superfamily_domains_isoform_for_script.csv"

The script goes on to generate a file for each unique protein name.  Each file contains the domains for the canonical sequence and the domains for the novel isoform sequence.  The following is an example of a file generated- though this file generation is done programmatically- "AAMDC_Q9H7C9_domains_canonical_isoform_compared.csv"

The following is the name of the text file that is output that contains information for each protein and its gain/loss of domains, as well as the number of each of those domains that was gained/lost.  Also included in this output file is whether or not the canonical sequence had domain assignments to begin with.
1) "domain_information_output.txt"

Also generated is a short table that highlights if the canonical sequences intially had domains assigned to it.  It can be found under the following name:
1)"df_canonical_initially.csv"
```

### nmd_determination.R
```
This script takes in the amino acid sequences for both the canonical protein sequence and the novel isoform protein sequence, and uses this information to determine if the novel isoform is a potential Nonsense-mediated Decay (NMD) candidate or not. An output text file is generated with the information for each protein, named: "nmd_information_output.txt". There is also a small dataframe generated that includes the information in the initial file read into the script, along with a new column for NMD candidacy. This csv file is named: "intron_positions_for_nmd_with_nmd_candidacy.csv".

The input file for this script can be found under: "intron_positions_for_nmd.csv".  This includes the following column names and their corresponding informaton: "Gene_ID", "Seq_ID" (i.e. UniProt ID),	"Protein_Name" (no "_HUMAN" at the end of the name), "Query_match_in_JuncDB", "Final_intron_position", and	"Strand". Generating this file required previous determination as to if the insertion of the putative exon caused a Premature Termination Codon (PTC).  Only proteins that exhibited this characteristic were included in the table.  JuncDB wa used to determine the final intron position (i.e. the final exon-exon junction) for each protein, as this information is involved in the determination of NMD.

FASTA files were also put together to include the canonical sequence and the novel isoform sequence for each protein that contained a PTC.  The following is an example of such a file: "AAMDC_Q9H7C9_can_iso_seqs.fasta". This file would be used for the script in determining the number of nucleotides in each sequence.

The output file, entitled: "nmd_information_output.txt", informs the user of the file name being analyzed, the intron position, the strand, and the number of nucleotides the PTC is from the intron position. Also outputted in the file is if the isoform is a NMD candidate or not.

The second output file is "intron_positions_for_nmd_with_nmd_candidacy.csv", which is a simple table that includes all of the information from "intron_positions_for_nmd.csv", with an additional column "NMD_candidate", with possible values of "yes", "no", or "NA".
```

### Differential Expresssion Analysis Scripts for Individual recount Studies
```
The purpose of this script is to conduct a Differential Expression Analysis of a set of putative exons.  In this case, the putative exons are being observed for differential expression when regarding psychiatric disease, including schizophrenia and bipolar disorder. There are three steps to complete the analysis.  The script begins with generating a GenomicRanges object of the putative exons that the user wishes to check for differential expression. The second step includes calculating the coverage of the desired regions, scaling these counts, adding necessary colData, and combining all of the coverage matrices into one overall coverage matrix.  The third step includes Exploratory Analysis and the Differential Expression Analysis.

It is important to note that the coordinates in recount are from the hg38 assembly. If yours are assembly hg19, be sure to convert them to assembly hg38. The UCSC Genome Browser has created a great utility for converting coordinates between assemblies.  The link to the converter can be found [here](https://genome.ucsc.edu/cgi-bin/hgLiftOver). 

The input needed for this script is a file that contains all of the necessary information to assemble a GRanges object- seqnames (i.e. chromosome #, the start and end position of teh region(s), and the strand that the region is on).  See the file "putative_region_info_for_GRanges.csv" for an example of input information.  
```
